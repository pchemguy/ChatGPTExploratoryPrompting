# Metaprompts

## Init

Analyze the following prompt and consider if instructions are clear and unambiguous. Provide feedback/questions on any potential issues.

## Revise

Revise the prompt with the following answers, analyze it again and consider if there are still some questions (of if some answers are unclear). Provide additional feedback, if necessary, or generated a revised prompt with clear and well organized structure and language.

**# Answers**

# Prompt: Creation of Internal Hyperlinks from In-Text Bibliography Citations

## Persona:

You are a highly-qualified expert in VBA6 and Python programming.

You follow the best coding practices, leading guidelines, and guides for Python (such as Google Python Style Guide) and you also adapt and apply any such practices/guidelines, whenever possible, to the generated VBA code. For example, you generate detailed documentation (DocStrings) for VBA routines by adapting relevant Python guidelines; the same applies to identifier names (variables, constants, procedures).

**For VBA, you apply the following additional guidelines:**

- **Primary Host Platform:**
    - Microsoft Word 2002/XP.
- **Explicit Code:**
    - Prefer explicit over implicit.
    - Use `Option Explicit` at the module level.
    - Declare all variables with specific types. Use `Variant` only when necessary.
- **Named Constants:**
    - Avoid hardcoding constants (like bookmark prefixes or parts of field codes); use meaningful names for constants, declaring them at the lowest appropriate scope (procedure or module level).
- **Error Handling:**
    - Generate appropriate error handling code (`On Error GoTo ...`).
    - Raise descriptive errors for specified conditions (see Task details).
- **Reusability & Structure:**
    - Write reusable functions and procedures instead of duplicating code.
    - Avoid tightly coupling code with specific document elements where possible; use parameters if designing helper functions.
    - Organize the code logically within the module.
- **Object Usage:**
    - Prefer early binding with specific object types (e.g., `Dim rng As Word.Range`).
    - Include information about any required project references (beyond standard Word/Office/VBA) in the module DocString (e.g., "Microsoft Scripting Runtime").
    - Use `Scripting.Dictionary` when a key-value collection is needed (similar to Python dictionaries).
    - Always use the `ActiveDocument` property explicitly when referring to the current document and its contents.
    - Use the `With` block to simplify repeated references to the same object (e.g., `With ActiveDocument`).

## Task:

Create a self-contained VBA6 macro module (`.bas` file content) for Microsoft Word (2002/XP) that automates the creation of internal hyperlinks from in-text bibliography citations to their corresponding entries in the bibliography list. The macro should operate automatically without user prompts. Optimization for very large documents is not a primary concern.

### Document Structure Assumptions:

1. **Citations:** Located within the main body of the `ActiveDocument`.
    - Follow a numbered style, enclosed in square brackets. Examples: `[23]`, `[25,26,30]`, `[17-19]`, `[17-19, 23, 25]`.
    - Citations can be plain text or the result (displayed text) of fields (e.g., Zotero citation fields). The macro should process the **displayed text**.
    - Numbers within brackets are separated by commas (`,`) and/or hyphens (`-`) indicating ranges.
    - An optional single space may follow a comma separator (`[25, 26]` is valid).
2. **Bibliography:** Located within the same `ActiveDocument`.
    - The bibliography section is generated by or associated with a Word field containing both the substrings "`ADDIN ZOTERO_BIBL`" and "`CSL_BIBLIOGRAPHY`".
    - Individual bibliography entries within this section are paragraphs that begin with the citation number in brackets, followed immediately by a tab character: `[#]{TAB}` (e.g., `[7]{TAB}Author Name...`).

### Macro Processing Steps:

The macro must perform the following actions **in this order**:

1. **Cleanup:**
    - Delete all existing bookmarks in the `ActiveDocument` whose names start with "`BIB_`".
    - Find and remove all existing hyperlinks in the `ActiveDocument` whose `SubAddress` property (target bookmark) starts with "`BIB_`".
2. **Bibliography Scanning & Bookmark Creation:**
    - Search the `ActiveDocument.Fields` collection to find the specific Zotero bibliography field (containing "`ADDIN ZOTERO_BIBL`" and "`CSL_BIBLIOGRAPHY`").
    - **Error Handling:** If this field is not found, raise a descriptive error and stop execution.
    - Identify the paragraphs constituting the bibliography list associated with this field (likely the paragraphs within the field's result range).
    - For each paragraph in the bibliography that starts with the pattern `[#]{TAB}`:
        - Extract the citation number `#`.
        - Create a bookmark named exactly "`BIB_#`" (e.g., "`BIB_7`", "`BIB_23`").
        - The bookmark must cover **only** the bracketed number text (e.g., `[7]`) at the very beginning of the paragraph, excluding the tab character or any subsequent text.
3. **Citation Scanning & Validation:**
    - Scan the entire main body of the `ActiveDocument` (excluding the bibliography section itself, if feasible, otherwise scan all) for text matching the citation patterns (e.g., `[23]`, `[25, 26]`, `[17-19, 23]`). Operate on the displayed text.
    - Parse _all_ found citation patterns throughout the document to identify _every_ unique citation number referenced (e.g., `[17-19, 23]` refers to numbers 17, 18, 19, 23).
    - **Orphan Check:** Before creating any hyperlinks, verify that a corresponding `BIB_#` bookmark (created in Step 2) exists for _every single_ citation number identified in this step.
    - **Error Handling:** If any referenced citation number does _not_ have a corresponding `BIB_#` bookmark, raise a descriptive error listing the missing/orphan citation number(s) and stop execution.
4. **Hyperlink Creation:**
    - If the orphan check passes, iterate through the found citation patterns again.
    - For each number or number range _within_ the brackets of a citation pattern:
        - Select the text corresponding _only_ to the number(s) (e.g., select `"23"`, `"25"`, `"26"`, `"30"`, `"17-19"`). Do **not** include the brackets `[]`, commas `,`, or spaces .
        - Create a hyperlink for the selected text.
        - The hyperlink's `SubAddress` (target) must be the bookmark corresponding to the _first_ number in the selection (e.g., for `"17-19"`, the target is `BIB_17`; for `"23"`, the target is `BIB_23`).
        - Ensure the hyperlink strictly covers only the intended number/range text.

# Code: Creation of Internal Hyperlinks from In-Text Bibliography Citations

```bas
'@Folder("Project")
Option Explicit

'---------------------------------------------------------------------------------------
' Module    : modBibliographyHyperlinker
' Author    : Gemini
' Date      : 16/04/2025
' Version   : 2.6
' Purpose   : Creates internal hyperlinks from in-text bibliography citations
'             (e.g., [1], [2, 3], [4-6], [9-14]) to corresponding bibliography entries
'             marked with bookmarks (BIB_1, BIB_2, etc.). Handles hyphen and en dash ranges.
' Changes   : v1.1 - Corrected object reference after delete in hyperlink cleanup.
'                  - Adjusted bibliography entry pattern to handle optional leading page break (\f).
'                  - Refined bookmark range calculation to exclude page break.
'           : v1.2 - Corrected object reference after delete in bookmark cleanup, mirroring hyperlink fix.
'           : v1.3 - Revised hyperlink creation logic in CreateCitationHyperlinks to use
'                    Range.Find for locating component text within the citation, improving robustness.
'           : v1.4 - Changed CreateCitationHyperlinks to use an iterative RegExp approach (REVERTED in v1.8).
'           : v1.5 - Replaced Debug.Print with file logging ({DocName}.log in doc path).
'                  - Added SetupLogFile, LogMessage, CloseLogFile helpers.
'                  - Added error handling for unsaved document.
'                  - Added detailed debug logging for bookmark range calculation.
'           : v1.6 - Changed bookmark range definition in CreateBibliographyBookmarks to use
'                    Collapse/MoveStart/MoveEnd method for potentially better reliability.
'           : v1.7 - Removed detailed debug logging for bookmark range calculation.
'           : v1.8 - Reverted hyperlink creation to loop through initial matches (like v1.3).
'                  - Added reading .Text before Range.Find for component text as potential fix.
'           : v1.9 - Step 4 Hyperlink creation now uses iterative Range.Find with wildcards
'                    to locate citations, avoiding reliance on stale RegExp indices.
'                    RegExp still used to parse inner text of found citations.
'           : v2.0 - Added check in CreateCitationHyperlinksIterativeFind to skip processing
'                    citations found within the bibliography range itself.
'           : v2.1 - Updated citation patterns (Wildcard Find, Component RegExp, Validation RegExp)
'                    to handle en dash in addition to hyphen (-) for ranges.
'           : v2.2 - Replaced literal en dash character in patterns with ChrW(8211).
'                  - Added detailed logging for component parsing/finding.
'           : v2.3 - Replaced literal en dash character in comments/text with hyphen or description.
'           : v2.4 - Replaced Const pattern definitions using ChrW with Private Functions
'                    to avoid VBA compile error ("Constant expression required").
'           : v2.5 - Reorganized module structure: Constants grouped at top.
'           : v2.6 - Removed extra debug logging from hyperlink creation step (Step 4).
'---------------------------------------------------------------------------------------
' References:
'   - Microsoft Word XX.X Object Library (where XX.X is your version)
'   - Microsoft VBScript Regular Expressions 5.5
'   - Microsoft Scripting Runtime
'---------------------------------------------------------------------------------------

'--- Constants ---
Private Const BIB_BOOKMARK_PREFIX As String = "BIB_"
Private Const ZOTERO_FIELD_PART1 As String = "ADDIN ZOTERO_BIBL"
Private Const ZOTERO_FIELD_PART2 As String = "CSL_BIBLIOGRAPHY"
' Regular expression to find bibliography entries like "[123]{TAB}"
' Allows for an optional leading form feed (page break) character \f (Chr(12))
Private Const BIB_ENTRY_PATTERN As String = "^\f?\[(\d+)\]" & vbTab

'--- Error Numbers ---
Private Const ERR_BIB_FIELD_NOT_FOUND As Long = vbObjectError + 1001
Private Const ERR_ORPHAN_CITATIONS As Long = vbObjectError + 1002
Private Const ERR_REGEX_ERROR As Long = vbObjectError + 1003
Private Const ERR_DOC_NOT_SAVED As Long = vbObjectError + 1004 ' For file logging


'--- Module Level Variables for Logging ---
Private m_LogFileNum As Integer ' File handle for the log file
Private m_LogFilePath As String ' Full path to the log file
Private m_LoggingEnabled As Boolean ' Flag to indicate if logging is active


'=======================================================================================
'   MAIN PROCEDURE
'=======================================================================================

Public Sub CreateBibliographyHyperlinks()
'---------------------------------------------------------------------------------------
' Procedure : CreateBibliographyHyperlinks
' Author    : Gemini
' Date      : 16/04/2025
' Purpose   : Main routine to orchestrate the bibliography hyperlink creation process.
'             Logs progress and errors to a file named {DocName}.log.
'             Follows the steps outlined in the requirements:
'             1. Setup Logging & Cleanup existing bookmarks/hyperlinks.
'             2. Scan bibliography, create bookmarks, and store their numbers.
'             3. Scan document (using RegExp) for citations for validation only.
'             4. Create hyperlinks iteratively using Range.Find, skipping bibliography section.
'             5. Close Log file.
' Notes     : Uses early binding and requires references to:
'             - Microsoft VBScript Regular Expressions 5.5
'             - Microsoft Scripting Runtime
'---------------------------------------------------------------------------------------
    Dim bibField As Word.Field
    Dim bibRange As Word.Range ' Will hold the bibliography range
    Dim createdBookmarks As Scripting.Dictionary ' Key: Bib number (Long), Value: Bookmark Name (String)
    Dim referencedCitations As Scripting.Dictionary ' Key: Citation number (Long), Value: 1 (just to track existence)
    Dim orphanCitations As Collection
    Dim regExVal As RegExp ' RegExp object for validation scan ONLY
    Dim validationMatches As MatchCollection ' For initial validation scan ONLY
    Dim i As Long
    Dim doc As Word.Document
    Dim citeKey As Variant
    Dim errorDescription As String

    On Error GoTo ErrorHandler

    Set doc = ActiveDocument ' Explicitly use ActiveDocument

    '--- Step 1a: Setup Logging ---
    Call SetupLogFile(doc) ' Attempt to open log file

    Call LogMessage("------------------------------------------------------------")
    Call LogMessage("CreateBibliographyHyperlinks started at " & Format(Now, "yyyy-mm-dd hh:nn:ss"))
    Call LogMessage("Processing document: " & doc.FullName)

    ' Ensure necessary references are available
    ' Test creation of RegExp and Dictionary objects early
    On Error Resume Next ' Temporarily ignore errors for object creation check
    Set regExVal = New RegExp ' Renamed to avoid confusion
    Set createdBookmarks = New Scripting.Dictionary
    Set referencedCitations = New Scripting.Dictionary
    If Err.Number <> 0 Then
        Call LogMessage("ERROR: Required object could not be created. Check References (RegExp, Scripting). Error: " & Err.Description)
        Err.Raise Err.Number, "CreateBibliographyHyperlinks (Object Creation)", "Required object could not be created. Check VBA References (Microsoft VBScript Regular Expressions 5.5, Microsoft Scripting Runtime)."
    End If
    On Error GoTo ErrorHandler ' Restore error handling

    '--- Step 1b: Cleanup ---
    Call LogMessage("Step 1: Cleaning up existing bookmarks and hyperlinks...")
    Call DeleteBibBookmarks(doc)
    Call DeleteBibHyperlinks(doc)
    Call LogMessage("Cleanup complete.")

    '--- Step 2: Bibliography Scanning & Bookmark Creation ---
    Call LogMessage("Step 2: Scanning bibliography and creating bookmarks...")
    ' Find the Zotero bibliography field
    Set bibField = FindZoteroBibliographyField(doc)
    If bibField Is Nothing Then
        errorDescription = "Could not find the Zotero bibliography field containing '" & _
                           ZOTERO_FIELD_PART1 & "' and '" & ZOTERO_FIELD_PART2 & "'."
        Call LogMessage("ERROR: " & errorDescription) ' Log before raising
        Err.Raise ERR_BIB_FIELD_NOT_FOUND, "CreateBibliographyHyperlinks", errorDescription
    End If
    Call LogMessage("Bibliography field found: " & bibField.Code.Text)

    ' Get the range containing the bibliography entries
    Set bibRange = bibField.Result ' Store the bibliography range
    If bibRange Is Nothing Then
        Call LogMessage("Warning: Bibliography field result range is Nothing. No bookmarks created.")
        ' bibRange remains Nothing, hyperlink creation will process whole doc
    Else
        ' Create bookmarks and store numbers
        Set createdBookmarks = CreateBibliographyBookmarks(bibRange)
        Call LogMessage("Created " & createdBookmarks.Count & " bibliography bookmarks.")
        If createdBookmarks.Count = 0 Then
             Call LogMessage("Warning: No bibliography entries matching pattern '" & BIB_ENTRY_PATTERN & "' found. No bookmarks created.")
             ' Decide if this should be an error or proceed
        End If
    End If


    '--- Step 3: Citation Scanning & Validation (Using RegExp - for validation ONLY) ---
    ' Perform ONE initial RegExp scan JUST for validation purposes before modifying the doc
    Call LogMessage("Step 3: Scanning document for citations using RegExp (for validation pre-check)...")
    With regExVal ' Use the validation RegExp object
        .Global = True
        .MultiLine = True
        .IgnoreCase = False
        .Pattern = GetValidationPattern() ' Use function call
    End With

    ' Scan the entire document content for validation
    Set validationMatches = regExVal.Execute(doc.Content.Text) ' Store matches for validation
    Call LogMessage("Found " & validationMatches.Count & " potential citation patterns via RegExp for validation.")

    If validationMatches.Count > 0 Then
        ' Collect all unique citation numbers referenced in the document
        Set referencedCitations = GetAllReferencedCitationNumbers(validationMatches) ' This function still works with RegExp matches
        Call LogMessage("Found " & referencedCitations.Count & " unique referenced citation numbers for validation.")

        ' Validate referenced citations against created bookmarks (Orphan Check)
        Set orphanCitations = FindOrphanCitations(referencedCitations, createdBookmarks)

        If orphanCitations.Count > 0 Then
            errorDescription = "Orphan citation(s) found (cited in text but no matching bibliography entry/bookmark): "
            For i = 1 To orphanCitations.Count
                errorDescription = errorDescription & orphanCitations(i) & IIf(i < orphanCitations.Count, ", ", "")
            Next i
            Call LogMessage("ERROR: " & errorDescription) ' Log before raising
            Err.Raise ERR_ORPHAN_CITATIONS, "CreateBibliographyHyperlinks", errorDescription
        End If
        Call LogMessage("Validation successful: All referenced citations have corresponding bookmarks.")
    Else
        Call LogMessage("No citation patterns found in the document. Skipping hyperlink creation.")
        GoTo ProcedureExit ' Nothing more to do
    End If
    ' Clear validation-only objects
    Set validationMatches = Nothing
    Set referencedCitations = Nothing
    Set orphanCitations = Nothing
    Set regExVal = Nothing ' Clear validation RegExp object


    '--- Step 4: Hyperlink Creation (Iterative Find Approach) ---
    Call LogMessage("Step 4: Creating hyperlinks iteratively using Range.Find...")
    ' Pass the bibliography range to the helper function
    Call CreateCitationHyperlinksIterativeFind(doc, createdBookmarks, bibRange)
    Call LogMessage("Hyperlink creation process complete.")

    MsgBox "Bibliography hyperlinks created successfully! See log file for details:" & vbCrLf & m_LogFilePath, vbInformation

ProcedureExit:
    Call LogMessage("CreateBibliographyHyperlinks finished at " & Format(Now, "yyyy-mm-dd hh:nn:ss"))
    Call LogMessage("------------------------------------------------------------")
    Call CloseLogFile ' Ensure log file is closed on normal exit
    ' Clean up objects
    Set bibField = Nothing
    Set bibRange = Nothing
    Set createdBookmarks = Nothing
    Set referencedCitations = Nothing ' Already cleared after validation
    Set orphanCitations = Nothing   ' Already cleared after validation
    Set regExVal = Nothing          ' Already cleared after validation
    Set validationMatches = Nothing ' Already cleared after validation
    Set doc = Nothing
    Exit Sub

ErrorHandler:
    Dim ErrMsg As String
    ErrMsg = "Error " & Err.Number & " (" & Err.Description & ") in module " & Err.Source & "."
    Call LogMessage("!!! MACRO ERROR: " & ErrMsg & " !!!") ' Log the error
    Call LogMessage("CreateBibliographyHyperlinks finished with ERROR at " & Format(Now, "yyyy-mm-dd hh:nn:ss"))
    Call LogMessage("------------------------------------------------------------")
    MsgBox ErrMsg, vbCritical, "Macro Error"
    ' Ensure log file is closed even if an error occurred
    On Error Resume Next ' Prevent error in cleanup from hiding original error
    Call CloseLogFile
    On Error GoTo 0
    ' Perform any necessary cleanup specific to the error handler if needed
    GoTo ProcedureExit ' Exit after handling error (log file already closed)

End Sub


'=======================================================================================
'   PATTERN GENERATING FUNCTIONS (Replaced Constants using ChrW)
'=======================================================================================

Private Function GetCitationFindPattern() As String
' Returns the Wildcard pattern for Word's Find to locate citations
' Handles digits, comma, hyphen, en dash within brackets
    GetCitationFindPattern = "\[[0-9,-" & ChrW(8211) & "]@\]"
End Function
'---------------------------------------------------------------------------------------

Private Function GetComponentPattern() As String
' Returns the RegExp pattern to parse components within a citation's inner text (numbers or ranges)
' Handles hyphen (-) or EN DASH (ChrW(8211)) as range separator
    GetComponentPattern = "(\d+)(?:[-" & ChrW(8211) & "](\d+))?"
End Function
'---------------------------------------------------------------------------------------

Private Function GetValidationPattern() As String
' Returns the RegExp pattern for the initial validation scan
' Handles digits, comma, hyphen, en dash, space within brackets
' Note: Hyphen is escaped as \- just in case, though likely not needed within [] here.
    GetValidationPattern = "\[([0-9,\-" & ChrW(8211) & "\s]+?)\]"
End Function
'---------------------------------------------------------------------------------------


'=======================================================================================
'   LOGGING HELPER FUNCTIONS
'=======================================================================================

Private Sub SetupLogFile(ByVal doc As Word.Document)
'---------------------------------------------------------------------------------------
' Procedure : SetupLogFile
' Purpose   : Initializes and opens the log file for writing. Overwrites existing file.
' Arguments : doc - The active Word document.
' Notes     : Requires document to be saved. Uses FileSystemObject.
'             Sets module-level variables m_LogFilePath and m_LogFileNum.
'---------------------------------------------------------------------------------------
    Dim fso As Object ' FileSystemObject
    Dim docPath As String
    Dim baseName As String

    m_LoggingEnabled = False ' Assume failure initially
    m_LogFileNum = 0

    ' Check if document is saved
    docPath = ""
    On Error Resume Next ' Handle error if document properties not available
    docPath = doc.Path
    On Error GoTo 0
    If docPath = "" Then
        Err.Raise ERR_DOC_NOT_SAVED, "SetupLogFile", _
                  "Document must be saved before logging can be enabled."
        Exit Sub ' Should not be reached due to Err.Raise
    End If

    ' Create FileSystemObject
    On Error Resume Next ' Handle FSO creation error (e.g., scripting disabled)
    Set fso = CreateObject("Scripting.FileSystemObject")
    If Err.Number <> 0 Then
        MsgBox "Could not create FileSystemObject. Logging to file disabled." & vbCrLf & _
               "Ensure 'Microsoft Scripting Runtime' reference is enabled and scripting is allowed.", vbExclamation
        Exit Sub ' Cannot proceed with file logging
    End If
    On Error GoTo 0 ' Restore error handling

    ' Construct log file path
    baseName = fso.GetBaseName(doc.Name)
    m_LogFilePath = fso.BuildPath(docPath, baseName & ".log")

    ' Get a free file handle and open the file for output (overwrite)
    On Error Resume Next ' Handle file access errors
    m_LogFileNum = FreeFile
    Open m_LogFilePath For Output As #m_LogFileNum
    If Err.Number <> 0 Then
        m_LogFileNum = 0 ' Reset file number
        MsgBox "Could not open log file for writing:" & vbCrLf & m_LogFilePath & vbCrLf & _
               "Error: " & Err.Description & vbCrLf & _
               "Logging to file disabled.", vbExclamation
        m_LogFilePath = ""
        Exit Sub ' Cannot proceed with file logging
    End If
    On Error GoTo 0 ' Restore error handling

    m_LoggingEnabled = True ' Logging is now active
    ' Write header
    Print #m_LogFileNum, "Log File for: " & doc.FullName
    Print #m_LogFileNum, "Macro Run Started: " & Format(Now, "yyyy-mm-dd hh:nn:ss")
    Print #m_LogFileNum, String(70, "-") ' Separator line

    Set fso = Nothing
End Sub
'---------------------------------------------------------------------------------------

Private Sub LogMessage(ByVal message As String)
'---------------------------------------------------------------------------------------
' Procedure : LogMessage
' Purpose   : Writes a message to the initialized log file, if enabled.
' Arguments : message - The string message to log.
'---------------------------------------------------------------------------------------
    ' Only write if logging was successfully set up
    If m_LoggingEnabled And m_LogFileNum > 0 Then
        On Error Resume Next ' Avoid errors here stopping the macro
        Print #m_LogFileNum, Format(Now, "hh:nn:ss") & " - " & message
        If Err.Number <> 0 Then
            ' Optionally report write error? For now, just ignore.
            Debug.Print "LOGGING ERROR: Could not write to log file. Error: " & Err.Description ' Fallback
        End If
        On Error GoTo 0
    Else
        ' Fallback to immediate window if logging isn't active
        Debug.Print message
    End If
End Sub
'---------------------------------------------------------------------------------------

Private Sub CloseLogFile()
'---------------------------------------------------------------------------------------
' Procedure : CloseLogFile
' Purpose   : Closes the log file if it was opened.
'---------------------------------------------------------------------------------------
    If m_LoggingEnabled And m_LogFileNum > 0 Then
        On Error Resume Next ' Avoid errors during close
        Print #m_LogFileNum, String(70, "-") ' Separator line
        Print #m_LogFileNum, "Log File Closed: " & Format(Now, "yyyy-mm-dd hh:nn:ss")
        Close #m_LogFileNum
        m_LogFileNum = 0 ' Reset file number
        m_LoggingEnabled = False ' Disable logging flag
        On Error GoTo 0
    End If
    ' Keep m_LogFilePath so it can be shown in the final message box
End Sub
'---------------------------------------------------------------------------------------


'=======================================================================================
'   CORE HELPER FUNCTIONS & PROCEDURES
'=======================================================================================


Private Sub DeleteBibBookmarks(ByVal doc As Word.Document)
'---------------------------------------------------------------------------------------
' Procedure : DeleteBibBookmarks
' Purpose   : Deletes all bookmarks in the document whose names start with BIB_BOOKMARK_PREFIX.
' Arguments : doc - The Word Document object to process.
'---------------------------------------------------------------------------------------
    Dim bm As Word.Bookmark
    Dim i As Long
    Dim bookmarkName As String ' Store name before deleting

    ' Iterate backwards because we are deleting items from the collection
    For i = doc.Bookmarks.Count To 1 Step -1
        Set bm = doc.Bookmarks(i)
        If bm.Name Like BIB_BOOKMARK_PREFIX & "*" Then
            bookmarkName = bm.Name ' Store the name *before* deleting
            bm.Delete             ' Delete the bookmark
            Call LogMessage("Deleted bookmark: " & bookmarkName) ' Log the stored name
        End If
    Next i
    Set bm = Nothing
End Sub
'---------------------------------------------------------------------------------------

Private Sub DeleteBibHyperlinks(ByVal doc As Word.Document)
'---------------------------------------------------------------------------------------
' Procedure : DeleteBibHyperlinks
' Purpose   : Deletes all hyperlinks in the document whose SubAddress starts with BIB_BOOKMARK_PREFIX.
' Arguments : doc - The Word Document object to process.
'---------------------------------------------------------------------------------------
    Dim hl As Word.Hyperlink
    Dim i As Long
    Dim targetAddress As String ' Store address before deleting

    ' Iterate backwards because removing hyperlinks might affect the collection index
    For i = doc.Hyperlinks.Count To 1 Step -1
        Set hl = doc.Hyperlinks(i)
        targetAddress = "" ' Reset for safety
        On Error Resume Next ' Handle cases where SubAddress might be invalid or empty
        targetAddress = hl.SubAddress
        On Error GoTo 0 ' Restore default error handling

        If targetAddress Like BIB_BOOKMARK_PREFIX & "*" Then
            hl.Delete ' Delete the hyperlink first
            Call LogMessage("Deleted hyperlink targeting: " & targetAddress) ' Log stored address
        End If
    Next i
    Set hl = Nothing
End Sub
'---------------------------------------------------------------------------------------

Private Function FindZoteroBibliographyField(ByVal doc As Word.Document) As Word.Field
'---------------------------------------------------------------------------------------
' Function  : FindZoteroBibliographyField
' Purpose   : Finds the first field in the document containing both Zotero identifiers.
' Arguments : doc - The Word Document object to search within.
' Returns   : The found Word.Field object, or Nothing if not found.
'---------------------------------------------------------------------------------------
    Dim fld As Word.Field
    Dim fieldCode As String

    For Each fld In doc.Fields
        fieldCode = fld.Code.Text
        If InStr(1, fieldCode, ZOTERO_FIELD_PART1, vbTextCompare) > 0 And _
           InStr(1, fieldCode, ZOTERO_FIELD_PART2, vbTextCompare) > 0 Then
            Set FindZoteroBibliographyField = fld
            Exit Function ' Return the first match found
        End If
    Next fld

    ' If loop completes without finding the field
    Set FindZoteroBibliographyField = Nothing
End Function
'---------------------------------------------------------------------------------------

Private Function CreateBibliographyBookmarks(ByVal bibRange As Word.Range) As Scripting.Dictionary
'---------------------------------------------------------------------------------------
' Function  : CreateBibliographyBookmarks
' Purpose   : Scans paragraphs within the bibliography range, creates bookmarks
'             for entries matching "^\f?\[#]{TAB}", and returns a dictionary of created bookmarks.
'             Uses Collapse/MoveStart/MoveEnd to define bookmark range.
' Arguments : bibRange - The Word.Range object containing the bibliography entries.
' Returns   : A Scripting.Dictionary where Key=Bibliography Number (Long), Value=Bookmark Name (String).
' Requires  : Microsoft VBScript Regular Expressions 5.5, Microsoft Scripting Runtime
'---------------------------------------------------------------------------------------
    Dim para As Word.Paragraph
    Dim regEx As RegExp
    Dim matches As MatchCollection
    Dim match As match
    Dim bibNum As Long
    Dim bookmarkName As String
    Dim bookmarkRange As Word.Range
    Dim dictBookmarks As Scripting.Dictionary
    Dim paraText As String
    Dim matchText As String
    Dim bracketPos As Long
    Dim numLen As Integer
    Dim offsetToBracket As Long ' Characters from para start to '['

    Set dictBookmarks = New Scripting.Dictionary
    Set regEx = New RegExp

    ' Configure RegExp to find optional \f then "[#]{TAB}" at the start of a line
    With regEx
        .Pattern = BIB_ENTRY_PATTERN ' Uses "\f?\[(\d+)\]{TAB}"
        .Global = False ' Only find the first match per paragraph
        .MultiLine = False ' Check start of paragraph text
        .IgnoreCase = False
    End With

    ' Iterate through each paragraph in the bibliography range
    For Each para In bibRange.Paragraphs
        paraText = para.Range.Text ' Get text of the paragraph
        Set matches = regEx.Execute(paraText)

        If matches.Count > 0 Then
            Set match = matches(0)
            ' Extract the number (Group 1 of the pattern)
            bibNum = CLng(match.SubMatches(0))
            bookmarkName = BIB_BOOKMARK_PREFIX & bibNum
            matchText = match.Value ' Full matched text, e.g. "\f[7]\t" or "[7]\t"

            ' Find the starting position of '[' within the matched text
            bracketPos = InStr(1, matchText, "[")

            If bracketPos > 0 Then
                ' Calculate offset needed to move start point
                numLen = Len(match.SubMatches(0))
                offsetToBracket = match.FirstIndex + bracketPos - 1

                ' *** Define range using Collapse/MoveStart/MoveEnd ***
                Set bookmarkRange = para.Range.Duplicate ' Work on a copy
                bookmarkRange.Collapse wdCollapseStart     ' Go to start of paragraph
                bookmarkRange.MoveStart Unit:=wdCharacter, Count:=offsetToBracket ' Move start to '['
                bookmarkRange.MoveEnd Unit:=wdCharacter, Count:=numLen + 2       ' Move end past ']'
                ' *** End new range definition ***

            Else
                 Call LogMessage("Warning: Could not find '[' in matched text '" & matchText & "' for bibNum " & bibNum & ". Skipping bookmark.")
                 GoTo NextPara ' Skip to next paragraph if pattern match is unexpected
            End If

            ' Check if bookmark already exists (shouldn't due to cleanup, but good practice)
            If Not ActiveDocument.Bookmarks.Exists(bookmarkName) Then
                 ' Add the bookmark using the range defined by MoveStart/MoveEnd
                ActiveDocument.Bookmarks.Add Name:=bookmarkName, Range:=bookmarkRange
                ' Store in dictionary if successful
                If Not dictBookmarks.Exists(bibNum) Then
                    dictBookmarks.Add bibNum, bookmarkName
                    ' Log the actual text covered by the final range
                    Call LogMessage("Created bookmark: " & bookmarkName & " covering range text: '" & bookmarkRange.Text & "'")
                Else
                    Call LogMessage("Warning: Duplicate bibliography number found and ignored: " & bibNum)
                End If
            Else
                 Call LogMessage("Warning: Bookmark '" & bookmarkName & "' unexpectedly already exists. Skipped.")
            End If
        End If
NextPara:
    Next para

    Set CreateBibliographyBookmarks = dictBookmarks

    ' Cleanup
    Set para = Nothing
    Set regEx = Nothing
    Set matches = Nothing
    Set match = Nothing
    Set bookmarkRange = Nothing
    Set dictBookmarks = Nothing
End Function
'---------------------------------------------------------------------------------------

Private Function GetAllReferencedCitationNumbers(ByVal citationMatches As MatchCollection) As Scripting.Dictionary
'---------------------------------------------------------------------------------------
' Function  : GetAllReferencedCitationNumbers
' Purpose   : Parses all citation strings found by the main regex and returns a
'             dictionary containing all unique citation numbers referenced.
'             Used for the initial validation scan. Handles ranges with hyphen or en dash.
' Arguments : citationMatches - A MatchCollection from executing VALIDATION_CITATION_PATTERN on document content.
' Returns   : A Scripting.Dictionary where Key=Citation Number (Long), Value=1 (indicates presence).
' Requires  : Microsoft VBScript Regular Expressions 5.5, Microsoft Scripting Runtime
'---------------------------------------------------------------------------------------
    Dim dictReferenced As New Scripting.Dictionary
    Dim regExComp As New RegExp ' For parsing components like "1", "2-5", "9-14"
    Dim citationMatch As match
    Dim innerText As String
    Dim componentMatches As MatchCollection
    Dim componentMatch As match
    Dim startNum As Long
    Dim endNum As Long
    Dim i As Long

    ' Configure component regex (now handles hyphen OR en dash)
    With regExComp
        .Global = True
        .Pattern = GetComponentPattern() ' Use function call
    End With

    ' Process each citation found in the document
    For Each citationMatch In citationMatches
        innerText = Trim(citationMatch.SubMatches(0)) ' Get text inside brackets, e.g., "17-19, 23", "9-14"

        ' Find all numbers and ranges within the inner text
        Set componentMatches = regExComp.Execute(innerText)

        For Each componentMatch In componentMatches
            startNum = CLng(componentMatch.SubMatches(0))

            If componentMatch.SubMatches(1) <> "" Then ' It's a range (e.g., 17-19 or 9-14)
                endNum = CLng(componentMatch.SubMatches(1))
                If endNum < startNum Then endNum = startNum ' Handle invalid range like [5-3] as just [5]
                ' Add all numbers in the range to the dictionary
                For i = startNum To endNum
                    If Not dictReferenced.Exists(i) Then dictReferenced.Add i, 1
                Next i
            Else ' It's a single number
                If Not dictReferenced.Exists(startNum) Then dictReferenced.Add startNum, 1
            End If
        Next componentMatch
    Next citationMatch

    Set GetAllReferencedCitationNumbers = dictReferenced

    ' Cleanup
    Set dictReferenced = Nothing
    Set regExComp = Nothing
    Set citationMatch = Nothing
    Set componentMatches = Nothing
    Set componentMatch = Nothing

End Function
'---------------------------------------------------------------------------------------

Private Function FindOrphanCitations(ByVal referencedCitations As Scripting.Dictionary, ByVal createdBookmarks As Scripting.Dictionary) As Collection
'---------------------------------------------------------------------------------------
' Function  : FindOrphanCitations
' Purpose   : Compares referenced citation numbers against created bookmark numbers
'             and returns a collection of orphan numbers (referenced but no bookmark).
' Arguments : referencedCitations - Dictionary of numbers found in citations.
'             createdBookmarks - Dictionary of numbers for which bookmarks were created.
' Returns   : A Collection containing orphan citation numbers (Long). Empty if none found.
'---------------------------------------------------------------------------------------
    Dim orphans As New Collection
    Dim citeKey As Variant

    If referencedCitations Is Nothing Or createdBookmarks Is Nothing Then
        ' Handle potential Nothing dictionaries, though they should be initialized
        Set FindOrphanCitations = orphans
        Exit Function
    End If

    ' Check each referenced citation number
    For Each citeKey In referencedCitations.Keys
        If Not createdBookmarks.Exists(citeKey) Then
            orphans.Add CLng(citeKey) ' Add the orphan number to the collection
        End If
    Next citeKey

    Set FindOrphanCitations = orphans
    Set orphans = Nothing ' Clean up intermediate collection
End Function
'---------------------------------------------------------------------------------------

Private Sub CreateCitationHyperlinksIterativeFind(ByVal doc As Word.Document, ByVal createdBookmarks As Scripting.Dictionary, ByVal bibliographyRange As Word.Range)
'---------------------------------------------------------------------------------------
' Procedure : CreateCitationHyperlinksIterativeFind
' Author    : Gemini
' Date      : 16/04/2025
' Purpose   : Iteratively finds citations using Range.Find with wildcards,
'             parses inner text with RegExp, finds component text with Range.Find,
'             and creates hyperlinks. Skips citations found within the bibliographyRange.
' Arguments : doc - The Word Document object.
'             createdBookmarks - Dictionary of valid bookmark numbers/names.
'             bibliographyRange - The Range object representing the bibliography section (can be Nothing).
' Requires  : Microsoft VBScript Regular Expressions 5.5
' Notes     : Assumes orphan check has already passed. Handles hyphen and en dash ranges.
'---------------------------------------------------------------------------------------
    Dim regExComp As New RegExp         ' For parsing components like "1", "2-5", "9-14"
    Dim componentMatches As MatchCollection
    Dim componentMatch As match
    Dim startNum As Long
    Dim linkRange As Word.Range         ' Range of the component text (e.g., "1" or "17-19") to be linked
    Dim bookmarkTarget As String
    Dim linkText As String              ' Text of the component (e.g., "1" or "17-19")
    Dim searchRange As Word.Range       ' Range used for the main Find loop
    Dim citationContentRange As Word.Range ' Range of the currently found citation "[...]"
    Dim findCompRange As Word.Range     ' Duplicate range for finding component text within citationContentRange
    Dim innerText As String
    Dim isInsideBib As Boolean          ' Flag to check if citation is in bib
    Dim foundComp As Boolean            ' Flag for component find result

    ' Configure component regex (now handles hyphen OR en dash)
    With regExComp
        .Global = True
        .Pattern = GetComponentPattern() ' Use function call
    End With

    ' Initialize search range for the main Find loop
    Set searchRange = doc.Content

    ' Configure Find object for finding citations "[...]" (now includes en dash via ChrW)
    With searchRange.Find
        .ClearFormatting
        .Text = GetCitationFindPattern() ' Use function call
        .Forward = True
        .Wrap = wdFindStop
        .Format = False
        .MatchCase = False ' Case irrelevant for pattern
        .MatchWholeWord = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
        .MatchWildcards = True ' IMPORTANT: Enable wildcards

        ' Start the iterative Find loop
        Do While .Execute
            ' Check if Find actually found something and didn't just stop
            If searchRange.Find.Found Then
                ' searchRange now represents the found citation "[...]"
                Set citationContentRange = searchRange.Duplicate ' Work with a copy

                ' --- Check if the found citation is inside the bibliography range ---
                isInsideBib = False ' Reset flag
                If Not bibliographyRange Is Nothing Then
                    ' Use InRange but handle potential errors if ranges are complex/invalid
                    On Error Resume Next
                    isInsideBib = citationContentRange.InRange(bibliographyRange)
                    If Err.Number <> 0 Then
                        Call LogMessage("Warning: Error checking if citation range (" & citationContentRange.Start & "-" & citationContentRange.End & ") is inside bibliography range (" & bibliographyRange.Start & "-" & bibliographyRange.End & "). Error: " & Err.Description & ". Assuming NOT inside.")
                        isInsideBib = False ' Assume not inside if error occurs
                        Err.Clear
                    End If
                    On Error GoTo 0
                End If
                ' --- End check ---

                If isInsideBib Then
                    ' Skip processing this citation
                    Call LogMessage("Skipping citation match within bibliography: """ & citationContentRange.Text & """ found at index " & citationContentRange.Start)
                Else
                    ' Process this citation (it's outside the bibliography)
                    Call LogMessage("Processing citation match: """ & citationContentRange.Text & """ found at index " & citationContentRange.Start)

                    ' Extract inner text (safely handle potential short strings)
                    If Len(citationContentRange.Text) > 2 Then
                        innerText = Mid(citationContentRange.Text, 2, Len(citationContentRange.Text) - 2)
                    Else
                        innerText = "" ' Handle cases like "[]" if found
                    End If
                    ' Call LogMessage("  Inner text: '" & innerText & "'") ' DEBUG Removed v2.6

                    ' Use RegExp to parse components from the inner text string
                    Set componentMatches = regExComp.Execute(innerText)
                    ' Call LogMessage("  Found " & componentMatches.Count & " component(s) in inner text.") ' DEBUG Removed v2.6

                    For Each componentMatch In componentMatches
                        startNum = CLng(componentMatch.SubMatches(0))
                        linkText = componentMatch.Value ' The text to link, e.g., "17-19" or "9-14"
                        ' Call LogMessage("    Parsing component: '" & linkText & "' (StartNum: " & startNum & ")") ' DEBUG Removed v2.6

                        ' Use a duplicate of the citation range for finding the component text
                        Set findCompRange = citationContentRange.Duplicate

                        ' Now search *within* this citation range for the specific component text
                        ' Use Find WITHOUT wildcards here
                        With findCompRange.Find
                             .ClearFormatting
                             .Text = linkText
                             .Forward = True
                             .Wrap = wdFindStop
                             .Format = False
                             .MatchCase = True ' Match exact numbers/ranges
                             .MatchWholeWord = False ' Allow finding "1" in "1, 2"
                             .MatchWildcards = False ' IMPORTANT: Disable wildcards for component search
                             .MatchSoundsLike = False
                             .MatchAllWordForms = False

                             foundComp = .Execute ' Store result

                             ' Call LogMessage("      Find component '" & linkText & "' result: " & foundComp) ' DEBUG Removed v2.6

                             If foundComp Then ' Found the exact text range for the component
                                ' If found, findCompRange object now represents the component range
                                Set linkRange = findCompRange ' Assign the found range

                                ' Get the target bookmark name
                                If createdBookmarks.Exists(startNum) Then
                                    bookmarkTarget = createdBookmarks(startNum)

                                    ' Check if this specific range already has a hyperlink
                                    Dim existingLink As Boolean
                                    existingLink = False
                                    If linkRange.Hyperlinks.Count > 0 Then
                                        If linkRange.Hyperlinks(1).SubAddress = bookmarkTarget Then
                                            existingLink = True
                                        End If
                                    End If

                                    If Not existingLink Then
                                        ' Create the hyperlink
                                        doc.Hyperlinks.Add Anchor:=linkRange, SubAddress:=bookmarkTarget
                                        Call LogMessage("  Created hyperlink for """ & linkText & """ targeting """ & bookmarkTarget & """")
                                    Else
                                         Call LogMessage("  Skipped creating duplicate hyperlink for """ & linkText & """ targeting """ & bookmarkTarget & """")
                                    End If
                                Else
                                    Call LogMessage("  Error: Bookmark for citation number " & startNum & " (text: '" & linkText & "') not found during hyperlink creation phase.")
                                End If
                             Else
                                Call LogMessage("  Warning: Could not locate component text """ & linkText & """ within citation range text: """ & citationContentRange.Text & """. Hyperlink skipped.")
                             End If
                        End With ' End With findCompRange.Find

                    Next componentMatch ' Next component within the citation
                End If ' End If isInsideBib Check

                ' --- IMPORTANT: Collapse the main search range to continue AFTER the found citation ---
                ' (Do this regardless of whether it was skipped or processed)
                searchRange.Collapse wdCollapseEnd

            Else ' .Execute returned True but .Found was False (can happen at end of range)
                 Exit Do ' Stop searching
            End If ' End If .Found
        Loop ' Loop While .Execute
    End With ' End With searchRange.Find

    ' Cleanup
    Set regExComp = Nothing
    Set componentMatches = Nothing
    Set componentMatch = Nothing
    Set linkRange = Nothing
    Set citationContentRange = Nothing
    Set searchRange = Nothing
    Set findCompRange = Nothing

End Sub
'---------------------------------------------------------------------------------------
```

---
---

# INIT

Analyze the following prompt and consider if instructions are clear and unambiguous. Provide feedback/questions on any potential issues. Devise a workflow to be placed in place of "{To be suggested by AI}".

---

# Prompt: Recovery of Citation Fields

## Persona:

You are a highly-qualified expert in VBA6 and Python programming.

You follow the best coding practices, leading guidelines, and guides for Python (such as Google Python Style Guide) and you also adapt and apply any such practices/guidelines, whenever possible, to the generated VBA code. For example, you generate detailed documentation (DocStrings) for VBA routines by adapting relevant Python guidelines; the same applies to identifier names (variables, constants, procedures).

**For VBA, you apply the following additional guidelines:**

- **Primary Host Platform:**
    - Microsoft Word 2002/XP.
- **Explicit Code:**
    - Prefer explicit over implicit.
    - Use `Option Explicit` at the module level.
    - Declare all variables with specific types. Use `Variant` only when necessary.
- **Named Constants:**
    - Avoid hardcoding constants (like bookmark prefixes or parts of field codes); use meaningful names for constants, declaring them at the lowest appropriate scope (procedure or module level).
- **Error Handling:**
    - Generate appropriate error handling code (`On Error GoTo ...`).
    - Raise descriptive errors for specified conditions (see Task details).
- **Reusability & Structure:**
    - Write reusable functions and procedures instead of duplicating code.
    - Avoid tightly coupling code with specific document elements where possible; use parameters if designing helper functions.
    - Organize the code logically within the module.
- **Object Usage:**
    - Prefer early binding with specific object types (e.g., `Dim rng As Word.Range`).
    - Include information about any required project references (beyond standard Word/Office/VBA) in the module DocString (e.g., "Microsoft Scripting Runtime").
    - Use `Scripting.Dictionary` when a key-value collection is needed (similar to Python dictionaries).
    - Always use the `ActiveDocument` property explicitly when referring to the current document and its contents.
    - Use the `With` block to simplify repeated references to the same object (e.g., `With ActiveDocument`).

## Context:

When a section of text with field-based in-text bibliography citations from MS Word is submitted to GenAI via the text chat, the field information is lost (converted to textual representation). Assuming that the textual representation of references survive GenAI revision, there is a need to recover the original references after the revised text is pasted back into the source MS Word file.

## Task:

Create a self-contained VBA6 macro module (`.bas` file content) for Microsoft Word (2002/XP) for recovery of field-based in-text citations after revision of edited text. The text will be pasted next to original text containing all references. 

### Document Structure Assumptions:

**Citations:** Located within the main body of the `ActiveDocument`.
- Are Zotero-based fields and the field code begins with string "ADDIN ZOTERO_ITEM CSL_CITATION" (may be surrounded by spaces).
- Follow a numbered style, enclosed in square brackets. Examples: `[23]`, `[25,26,30]`, `[17-19]`, `[17-19, 23, 25]`.
- Citations can be plain text or the result (displayed text) of fields (e.g., Zotero citation fields). The macro should process the **displayed text**.
- Numbers within brackets are separated by commas (`,`) and/or hyphens (`-`) or en dashes indicating ranges.
- An optional single space may follow a comma separator (`[25, 26]` is valid).

### Macro Processing Steps:

{To be suggested by AI}

---
---

# REVISE

Analyze the following prompt and consider if instructions are clear and unambiguous. Provide feedback/questions on any potential issues. Carefully analyze execution logic (Macro Processing Steps).

---

# Prompt: Recovery of Citation Fields

## Persona:

You are a highly-qualified expert in VBA6 and Python programming.

You follow the best coding practices, leading guidelines, and guides for Python (such as Google Python Style Guide) and you also adapt and apply any such practices/guidelines, whenever possible, to the generated VBA code. For example, you generate detailed documentation (DocStrings) for VBA routines by adapting relevant Python guidelines; the same applies to identifier names (variables, constants, procedures).

**For VBA, you apply the following additional guidelines:**

- **Primary Host Platform:**
    - Microsoft Word 2002/XP.
- **Explicit Code:**
    - Prefer explicit over implicit.
    - Use `Option Explicit` at the module level.
    - Declare all variables with specific types. Use `Variant` only when necessary.
- **Named Constants:**
    - Avoid hardcoding constants (like bookmark prefixes or parts of field codes); use meaningful names for constants, declaring them at the lowest appropriate scope (procedure or module level).
- **Error Handling:**
    - Generate appropriate error handling code (`On Error GoTo ...`).
    - Raise descriptive errors for specified conditions (see Task details).
- **Reusability & Structure:**
    - Write reusable functions and procedures instead of duplicating code.
    - Avoid tightly coupling code with specific document elements where possible; use parameters if designing helper functions.
    - Organize the code logically within the module.
- **Object Usage:**
    - Prefer early binding with specific object types (e.g., `Dim rng As Word.Range`).
    - Include information about any required project references (beyond standard Word/Office/VBA) in the module DocString (e.g., "Microsoft Scripting Runtime").
    - Use `Scripting.Dictionary` when a key-value collection is needed (similar to Python dictionaries).
    - Always use the `ActiveDocument` property explicitly when referring to the current document and its contents.
    - Use the `With` block to simplify repeated references to the same object (e.g., `With ActiveDocument`).

## Context:

When a section of text with field-based in-text bibliography citations from MS Word is submitted to GenAI via the text chat, the field information is lost (converted to textual representation). Assuming that the textual representation of references survive GenAI revision, there is a need to recover the original references after the revised text is pasted back into the source MS Word file.

## Task:

Create a self-contained VBA6 macro module (`.bas` file content) for Microsoft Word (2002/XP) for recovery of field-based in-text citations after revision of edited text. The text will be pasted next to original text containing all references. 

### Document Structure Assumptions:

**Citations:** Located within the main body of the `ActiveDocument`.
- Are Zotero-based fields and the field code begins with string "ADDIN ZOTERO_ITEM CSL_CITATION" (may be surrounded by spaces).
- Follow a numbered style, enclosed in square brackets. Examples: `[23]`, `[25,26,30]`, `[17-19]`, `[17-19, 23, 25]`.
- Citations can be plain text or the result (displayed text) of fields (e.g., Zotero citation fields). The macro should process the **displayed text**.
- Numbers within brackets are separated by commas (`,`) and/or hyphens (`-`) or en dashes indicating ranges.
- An optional single space may follow a comma separator (`[25, 26]` is valid).

### Macro Processing Steps:

1.  **Initialization & Pre-checks:**
    * Declare all variables with explicit types (`Dim`), including object variables for `Scripting.Dictionary`, `Word.Field`, `Word.Range`, and `VBScript_RegExp_55.RegExp` (or use `Object` for late binding for Dictionary and RegExp). Ensure necessary project references ("Microsoft Scripting Runtime", "Microsoft VBScript Regular Expressions 5.5") are noted if using early binding.
    * Use `Option Explicit` at the top of the module.
    * Set up error handling: `On Error GoTo ErrorHandler`.
    * Turn off screen updating for performance: `Application.ScreenUpdating = False`.
    * **Check Selection:** Verify that the user has selected text. If `Selection.Type = wdSelectionIP` or `Selection.Type = wdNoSelection`, raise a descriptive error (e.g., using `Err.Raise`) stating that the revised text block must be selected first, then go to the `CleanUp` section.
    * Store the user's selection range: `Set rngRevisedText = Selection.Range`.
2.  **Build Original Citation Map:**
    * Define constants:
        * `PRIVATE CONST ZOTERO_FIELD_MARKER As String = "ADDIN ZOTERO_ITEM CSL_CITATION"`
        * `PRIVATE CONST VALID_CITATION_PATTERN As String = "^\[\d+([-,–\s]+\d+)*\]$"` *' Regex pattern for [##], [##,##], [##-##], [##, ##-##] etc.*
    * Create a `Scripting.Dictionary` object (late or early binding). Let's call it `dictCitationMap`.
    * Create and configure a `VBScript_RegExp_55.RegExp` object for validating result text format (early binding). Let's call it `regExpValidator`.
        * `.Pattern = VALID_CITATION_PATTERN`
        * `.Global = False` *' Only need to test the whole string once*
        * `.IgnoreCase = False`
    * Iterate through each `Field` object `fld` in `ActiveDocument.Fields`.
    * **Identify Zotero Fields:** For each `fld`, check if `fld.Type = wdFieldAddin` AND `InStr(1, Trim(fld.Code.Text), ZOTERO_FIELD_MARKER, vbTextCompare) > 0`. 
    * **Map Field by Result:** If it's a Zotero field:
        * Get the displayed text: `strResultText = Trim(fld.Result.Text)`.
        * **Validate Result Format using RegExp:** Check if the `strResultText` matches the expected pattern using `If regExpValidator.Test(strResultText) Then`.
        * **Add to Dictionary:** If the format is valid and the key `strResultText` does *not* already exist in the dictionary (`If Not dictCitationMap.Exists(strResultText) Then`), add it: `dictCitationMap.Add Key:=strResultText, Item:=fld`. *' Map first encountered field for this result text.*
    * Release the validator RegExp object: `Set regExpValidator = Nothing`.
    * **Check if Map is Empty:** After iterating, if `dictCitationMap.Count = 0`, raise a descriptive error ("No valid Zotero citation fields matching the expected format '[##...]' were found. Cannot proceed."), then go to `CleanUp`.
3.  **Find and Replace Textual Citations in Selection:**
    * Create and configure a `VBScript_RegExp_55.RegExp` object for *finding* citations in the selection (late or early binding). Let's call it `regExpFinder`.
        * `.Pattern = "\[([^\]]+)\]"` *' Simple pattern to find bracketed text*
        * `.Global = True` *' Find all occurrences*
        * `.MultiLine = True`
        * `.IgnoreCase = False`
    * Execute the search on the selected text: `Set regExpMatches = regExpFinder.Execute(rngRevisedText.Text)`.
    * Create a collection or dynamic array (`Dim arrUnmatched() As String`) to store the text of citations that couldn't be matched. Initialize an unmatched items counter (`lngUnmatchedCount = 0`).
    * **Iterate Matches in Reverse:** Loop through `regExpMatches` from `regExpMatches.Count - 1` down to `0`.
        * For each `match`:
            * Get the full matched text: `strMatchedText = match.Value`.
            * **Check Map:** Look up `strMatchedText` in the dictionary: `If dictCitationMap.Exists(strMatchedText) Then`.
                * **If Found (Replace):**
                    * Retrieve the original field object: `Set originalField = dictCitationMap(strMatchedText)`.
                    * Get the original field's code: `strOriginalCode = originalField.Code.Text`.
                    * Define the `Range` within the selection for this match: `Set rngMatch = ActiveDocument.Range(Start:=rngRevisedText.Start + match.FirstIndex, End:=rngRevisedText.Start + match.FirstIndex + match.Length)`.
                    * Replace the text range with a new field: `Set newField = ActiveDocument.Fields.Add(Range:=rngMatch, Type:=wdFieldAddin, Text:=strOriginalCode, PreserveFormatting:=False)`.
                    * Optional: `newField.Update`.
                    * Release per-match objects: `Set originalField = Nothing`, `Set rngMatch = Nothing`, `Set newField = Nothing`.
                * **If Not Found (Log):**
                    * Resize `arrUnmatched` preserving existing items and add `strMatchedText`.
                    * Increment `lngUnmatchedCount`.
    * Release the finder RegExp object: `Set regExpFinder = Nothing`.
4.  **Reporting & Cleanup:**
    * **`CleanUp:`** Label.
    * Re-enable screen updating: `Application.ScreenUpdating = True`.
    * Release object variables: `Set dictCitationMap = Nothing`, `Set regExpFinder = Nothing` (if not already released), `Set regExpMatches = Nothing`, `Set rngRevisedText = Nothing`, etc.
    * **Display Summary Message:**
        * If `lngUnmatchedCount = 0`, show `MsgBox` "Citation recovery complete. All found textual citations were successfully replaced with Zotero fields.", `vbInformation`.
        * If `lngUnmatchedCount > 0`, build message string (e.g., `strMsg = "Citation recovery complete, but " & lngUnmatchedCount & " textual citation(s) could not be matched to original Zotero fields:\n\n" & Join(arrUnmatched, vbCrLf) & "\n\nPlease review these manually."`) and show `MsgBox strMsg, vbExclamation`.
    * Exit the subroutine: `Exit Sub`.
5.  **Error Handling:**
    * **`ErrorHandler:`** Label.
    * Store error details: `Dim lngErrNum As Long: lngErrNum = Err.Number`, `Dim strErrDesc As String: strErrDesc = Err.Description`.
    * Clear the error: `Err.Clear`.
    * Attempt to resume cleanup: `Resume CleanUp`. *' Try to run cleanup code*
    * If resuming cleanup fails or to ensure message is shown, add fallback:
    * Display `MsgBox` showing the error: `"An unexpected error occurred:\n\nError Number: " & lngErrNum & "\nDescription: " & strErrDesc`, `vbCritical`.
    * *' Consider adding End statement here if cleanup isn't guaranteed after critical error*

---
---

# Revised Prompt

# Prompt: Recovery of Citation Fields

## Persona:

You are a highly-qualified expert in VBA6 and Python programming.

You follow the best coding practices, leading guidelines, and guides for Python (such as Google Python Style Guide) and you also adapt and apply any such practices/guidelines, whenever possible, to the generated VBA code. For example, you generate detailed documentation (DocStrings) for VBA routines by adapting relevant Python guidelines; the same applies to identifier names (variables, constants, procedures).

**For VBA, you apply the following additional guidelines:**

-   **Primary Host Platform:**
    -   Microsoft Word 2002/XP.
-   **Explicit Code:**
    -   Prefer explicit over implicit.
    -   Use `Option Explicit` at the module level.
    -   Declare all variables with specific types. Use `Variant` only when necessary.
-   **Named Constants & Patterns:**
    -   Avoid hardcoding constants (like bookmark prefixes or parts of field codes); use meaningful names for constants, declaring them at the lowest appropriate scope (procedure or module level).
    -   Where patterns require special characters not allowed in `Const` (like the en dash), use private helper functions to return the pattern string. **Build these strings using character code functions (e.g., `ChrW(8211)` for en dash) instead of literal characters to ensure code compatibility with non-Unicode editors.**
-   **Error Handling:**
    -   Generate appropriate error handling code (`On Error GoTo ...`).
    -   Raise descriptive errors for specified conditions (see Task details).
-   **Reusability & Structure:**
    -   Write reusable functions and procedures instead of duplicating code.
    -   Avoid tightly coupling code with specific document elements where possible; use parameters if designing helper functions.
    -   Organize the code logically within the module (Constants, Variables, Public Subs, Private Subs/Functions).
-   **Object Usage:**
    -   Prefer early binding with specific object types (e.g., `Dim rng As Word.Range`).
    -   Include information about any required project references (beyond standard Word/Office/VBA) in the module DocString (e.g., "Microsoft Scripting Runtime", "Microsoft VBScript Regular Expressions 5.5").
    -   Use `Scripting.Dictionary` when a key-value collection is needed (similar to Python dictionaries).
    -   Always use the `ActiveDocument` property explicitly when referring to the current document and its contents.
    -   Use the `With` block to simplify repeated references to the same object (e.g., `With ActiveDocument`).

## Context:

When a section of text with field-based in-text bibliography citations from MS Word is submitted to GenAI via the text chat, the field information is lost (converted to textual representation). Assuming that the textual representation of references survive GenAI revision, there is a need to recover the original references after the revised text is pasted back into the source MS Word file.

## Task:

Create a self-contained VBA6 macro module (`.bas` file content) for Microsoft Word (2002/XP) for recovery of field-based in-text citations after revision of edited text. The revised text (containing textual citations like `[1]`, `[2-5]`, `[9{en dash}14]`) must be selected by the user before running the macro. The macro will attempt to replace these textual citations with the corresponding original Zotero field codes found elsewhere in the document.

*(Note: `{en dash}` in examples represents the en dash character, Unicode U+2013, implemented in VBA using `ChrW(8211)`).*

### Document Structure Assumptions:

**Citations:** Located within the main body of the `ActiveDocument`.
-   **Original Citations:** Are Zotero-based fields (`wdFieldAddin`) whose field code begins with the string `"ADDIN ZOTERO_ITEM CSL_CITATION"` (potentially surrounded by spaces).
-   **Citation Style (Field Result & Textual):** Follow a numbered style, enclosed in square brackets. Examples: `[23]`, `[25,26,30]`, `[17-19]`, `[17{en dash}19, 23, 25]` (handles hyphen `-` and en dash `{en dash}`).
-   An optional single space may follow a comma separator (`[25, 26]` is valid).
-   The macro processes the **displayed text** (field result) of original fields to build a map, and searches for matching textual representations in the user's selection.

### Macro Processing Steps:

1.  **Initialization & Pre-checks:**
    * Declare all variables with explicit types (`Dim`), including object variables. Use early binding where feasible (e.g., `Word.Field`, `Word.Range`) and note required references ("Microsoft Scripting Runtime", "Microsoft VBScript Regular Expressions 5.5").
    * Use `Option Explicit` at the top of the module.
    * Set up error handling: `On Error GoTo ErrorHandler`.
    * Turn off screen updating for performance: `Application.ScreenUpdating = False`.
    * **Check Selection:** Verify that the user has selected text (`Selection.Type = wdSelectionRange`). If not (`Selection.Type = wdSelectionIP` or `wdNoSelection`), raise a descriptive error stating that the revised text block must be selected first, then go to the `CleanUp` section.
    * Store the user's selection range: `Set rngRevisedText = Selection.Range`.
2.  **Build Original Citation Map:**
    * Define necessary constants/helper functions for patterns:
        * `ZOTERO_FIELD_MARKER`: `"ADDIN ZOTERO_ITEM CSL_CITATION"`
        * `GetValidationPattern()`: Function returning RegExp pattern `^\[\d+([-,{en dash}\s]+\d+)*\]$` (using `ChrW(8211)` for `{en dash}`). *Note: Assumes field result is exactly the bracketed citation after Trim.*
    * Create a `Scripting.Dictionary` object (`dictCitationMap`).
    * Create and configure a `RegExp` object (`regExpValidator`) using `GetValidationPattern()`.
    * Iterate through each `Field` object `fld` in `ActiveDocument.Fields`.
    * **Identify Zotero Fields:** Check `fld.Type = wdFieldAddin` AND `InStr(1, Trim(fld.Code.Text), ZOTERO_FIELD_MARKER, vbTextCompare) > 0`.
    * **Map Field by Result:** If it's a Zotero field:
        * Get the displayed text: `strResultText = Trim(fld.Result.Text)`.
        * **Validate Result Format:** Check `If regExpValidator.Test(strResultText) Then`.
        * **Add to Dictionary:** If format is valid and key `strResultText` does *not* already exist (`If Not dictCitationMap.Exists(strResultText) Then`), add it: `dictCitationMap.Add Key:=strResultText, Item:=fld`. *(Stores the first encountered Field object for each unique valid result text).*
    * Release the validator RegExp object: `Set regExpValidator = Nothing`.
    * **Check if Map is Empty:** If `dictCitationMap.Count = 0`, raise a descriptive error ("No valid Zotero citation fields matching the expected format '[#...]' were found in the document body. Cannot proceed."), then go to `CleanUp`.
3.  **Find and Replace Textual Citations in Selection (Iterative Find):**
    * Create a collection or dynamic array (`arrUnmatched`) to store the text of citations that couldn't be matched. Initialize counter (`lngUnmatchedCount = 0`).
    * Create a duplicate of the user's selection range to use for searching: `Set searchRange = rngRevisedText.Duplicate`.
    * **Configure `Find`:** Set up `searchRange.Find` properties:
        * `.ClearFormatting`
        * `.Text = GetCitationFindPattern()` *(Function returning wildcard pattern `\[[0-9,-{en dash}]@\]` using `ChrW(8211)`)*
        * `.MatchWildcards = True`
        * `.Forward = True`
        * `.Wrap = wdFindStop`
        * *(Other properties like `.Format`, `.MatchCase` etc. set appropriately)*
    * **Iterative Find Loop:** Start a loop: `Do While searchRange.Find.Execute`
        * **Check if Found:** Inside loop, check `If searchRange.Find.Found Then`.
        * Get the matched text: `strMatchedText = searchRange.Text`.
        * **Check Map:** Look up `strMatchedText` in the dictionary: `If dictCitationMap.Exists(strMatchedText) Then`.
        * **If Found (Replace):**
            * Retrieve the original field object: `Set originalField = dictCitationMap(strMatchedText)`.
            * Get the original field's code: `strOriginalCode = originalField.Code.Text`.
            * **Replace Range:** The `searchRange` currently represents the matched text. Replace it directly: `Set newField = ActiveDocument.Fields.Add(Range:=searchRange, Type:=wdFieldAddin, Text:=strOriginalCode, PreserveFormatting:=False)`.
            * **Do NOT update the field here (`newField.Update`)** to avoid potential slowdowns.
            * Release `originalField`, `newField`.
        * **If Not Found (Log):**
            * Resize `arrUnmatched` preserving existing items and add `strMatchedText`.
            * Increment `lngUnmatchedCount`.
        * **Advance Search Range:** Crucially, collapse the `searchRange` to its end point to continue searching *after* the found/replaced text: `searchRange.Collapse wdCollapseEnd`.
        * **Else (Not Found):** If `searchRange.Find.Found` was False, `Exit Do`.
    * **End Loop:** `Loop`
4.  **Reporting & Cleanup:**
    * **Optional Field Update:** *Before* releasing objects, consider adding code (perhaps conditional or commented out) to update all fields within the original selection range (`rngRevisedText.Fields.Update`) or the whole document (`ActiveDocument.Fields.Update`) if desired, or simply note in the final message that fields may need updating.
    * **`CleanUp:`** Label.
    * Re-enable screen updating: `Application.ScreenUpdating = True`.
    * Release *all* object variables (`dictCitationMap`, `searchRange`, `rngRevisedText`, etc.).
    * **Display Summary Message:**
        * If `lngUnmatchedCount = 0`, show `MsgBox` "Citation recovery complete. All found textual citations matching original field results were replaced with Zotero fields.", `vbInformation`. Add note about potential need for manual field update if not done automatically.
        * If `lngUnmatchedCount > 0`, build message string (e.g., `strMsg = "Citation recovery complete, but " & lngUnmatchedCount & " textual citation(s) could not be matched to original Zotero fields:\n\n" & Join(arrUnmatched, vbCrLf) & "\n\nPlease review these manually."`) and show `MsgBox strMsg, vbExclamation`. Add note about potential need for manual field update.
    * Exit the subroutine: `Exit Sub`.
5.  **Error Handling:**
    * **`ErrorHandler:`** Label.
    * Store error details (`Err.Number`, `Err.Description`).
    * Clear the error (`Err.Clear`).
    * Attempt to resume cleanup: `Resume CleanUp`.
    * Display fallback `MsgBox` showing the error details if cleanup fails or after cleanup attempt.

---
---

# Bookmarks Metaprompt

Help me create a prompt for generating a VBA6 / MS Word macro (use previous prompts as a reference). The macro would need to
1. Delete all bookmarks with `AUTO_` prefix.
2. Search for patterns `{{Supporting Information}}{{BMK: SI}}`.
3. Verify that
    1. The text inside the first pair {{}} is visible AND the rest is hidden.
    2. The content in the second pair starts with "BMK:".
    3. The trimmed part after "BMK:" contains only alphanumeric characters and underscores.
    4. The trimmed part after "BMK:" starts with a letter.
    5. The trimmed part after "BMK:" is no longer than 35 chars.
4. Create bookmark around the visible part.
Make sure to ask me for clarification, if necessary, before starting the prompt generation process.

---

# Prompt: VBA Macro for Auto Bookmark Creation from Pattern

## Persona:

You are a highly-qualified expert in VBA6 and Python programming.

You follow the best coding practices, leading guidelines, and guides for Python (such as Google Python Style Guide) and you also adapt and apply any such practices/guidelines, whenever possible, to the generated VBA code. For example, you generate detailed documentation (DocStrings) for VBA routines by adapting relevant Python guidelines; the same applies to identifier names (variables, constants, procedures).

**For VBA, you apply the following additional guidelines:**

-   **Primary Host Platform:**
    - Microsoft Word 2002/XP.
-   **Explicit Code:**
    - Prefer explicit over implicit.
    - Use `Option Explicit` at the module level.
    - Declare all variables with specific types. Use `Variant` only when necessary.
-   **Named Constants & Patterns:**
    - Avoid hardcoding constants (like bookmark prefixes); use meaningful names for constants, declaring them at the lowest appropriate scope (procedure or module level).
    - Where patterns require special characters not allowed in `Const` (like the en dash), use private helper functions to return the pattern string. **Build these strings using character code functions (e.g., `ChrW(8211)` for en dash) instead of literal characters to ensure code compatibility with non-Unicode editors.**
-   **Error Handling:**
    - Generate appropriate error handling code (`On Error GoTo ...`).
    - Raise descriptive errors for specified conditions (see Task details).
-   **Reusability & Structure:**
    - Write reusable functions and procedures instead of duplicating code.
    - Avoid tightly coupling code with specific document elements where possible; use parameters if designing helper functions.
    - Organize the code logically within the module (Constants, Variables, Public Subs, Private Subs/Functions).
-   **Object Usage:**
    - Prefer early binding with specific object types (e.g., `Dim rng As Word.Range`).
    - Include information about any required project references (beyond standard Word/Office/VBA) in the module DocString (e.g., "Microsoft Scripting Runtime", "Microsoft VBScript Regular Expressions 5.5"). 
    - Use `Scripting.Dictionary` when a key-value collection is needed (similar to Python dictionaries).
    - Always use the `ActiveDocument` property explicitly when referring to the current document and its contents.
    - Use the `With` block to simplify repeated references to the same object (e.g., `With ActiveDocument`).

## Context:

This macro is intended to automate the creation of bookmarks based on specially formatted text patterns within a Word document. The pattern consists of two parts enclosed in double curly braces: the first part contains visible text to be bookmarked, and the second part contains hidden metadata defining the bookmark name. Existing bookmarks created by this process (identified by a prefix) should be removed before new ones are created.

## Task:

Create a self-contained VBA6 macro module (`.bas` file content) for Microsoft Word (2002/XP) that performs the following:
1.  Deletes all existing bookmarks in the active document whose names begin with the prefix `AUTO_`.
2.  Searches for specific text patterns in the format `{{Visible Text}}{{BMK: BookmarkName}}`.
3.  Validates these patterns based on visibility formatting and naming rules.
4.  Creates new bookmarks with the prefix `AUTO_` around the validated visible text parts.
5.  Reports a summary of actions taken and any validation failures.

### Input Format / Document Assumptions:

- The macro operates on `ActiveDocument`.
- The target pattern is two sets of double curly braces immediately adjacent: `{{Visible Text}}{{BMK: BookmarkName}}`.
- The text within the first set of braces (`{{Visible Text}}`) is expected to be **visible** (i.e., the range covering these characters should *not* have `Font.Hidden = True` applied uniformly).
- The text within the second set of braces (`{{BMK: BookmarkName}}`) is expected to be **hidden** (i.e., the range covering these characters *must* have `Font.Hidden = True` applied uniformly). All braces must be **hidden** as well.
- The text inside the second (hidden) braces must start exactly with `BMK:` (case-sensitive).
- The `BookmarkName` part (the text after `BMK:` and before the closing `}}`, after trimming leading/trailing spaces) must adhere to the following rules:
    * Contains only alphanumeric characters (A-Z, a-z, 0-9) and underscores (`_`).
    * Must start with a letter (A-Z, a-z).
    * Must be no longer than 35 characters after trimming.

### Macro Processing Steps:

1.  **Initialization & Scope Definition:**
    * Declare all variables with explicit types (`Dim`), including necessary object variables (e.g., `Word.Document`, `Word.Range`, `Word.Bookmark`, `Word.Find`). Note required references ("Microsoft Scripting Runtime", "Microsoft VBScript Regular Expressions 5.5" - for name validation).
    * Use `Option Explicit`.
    * Set up error handling: `On Error GoTo ErrorHandler`.
    * Turn off screen updating: `Application.ScreenUpdating = False`.
    * **Determine Search Scope:**
        * Check `Selection.Type`. If it is `wdSelectionIP` or `wdNoSelection`, set the search range `rngSearchScope` to `ActiveDocument.Content`.
        * Otherwise (if there is a selection), set `rngSearchScope` to `Selection.Range`.
    * Initialize counters for deleted bookmarks, created bookmarks, and validation failures. Initialize a collection or dynamic array (`arrValidationFailures`) to store details of failures.
2.  **Delete Existing Bookmarks:**
    * Iterate through `ActiveDocument.Bookmarks` collection **in reverse** (from `.Count` down to 1).
    * For each bookmark `bm`, check if `bm.Name Like "AUTO_*"`.
    * If it matches, delete the bookmark: `bm.Delete`. Increment the deleted counter.
    * Log/report the count of deleted bookmarks.
3.  **Find Patterns & Validate (Iterative Find):**
    * Create and configure a `RegExp` object (`regExpNameValidator`) for validating the bookmark name part according to the rules (alphanumeric/underscore, starts with letter). Pattern example: `^[a-zA-Z][a-zA-Z0-9_]*$`.
    * Create a range object for the find operation, duplicating the `rngSearchScope`: `Set searchRange = rngSearchScope.Duplicate`.
    * **Configure `Find`:** Set up `searchRange.Find` properties:
        * `.ClearFormatting`
        * `.Text = "\{\{*\}\}\{\{*\}\}"` *(Wildcard pattern to find two adjacent double-brace blocks)*
        * `.MatchWildcards = True`
        * `.Forward = True`
        * `.Wrap = wdFindStop`
    * **Iterative Find Loop:** Start a loop: `Do While searchRange.Find.Execute`
        * Inside loop, check `If searchRange.Find.Found Then`.
        * **Parse Found Range:**
            * Get the found range text: `strFoundText = searchRange.Text`.
            * Attempt to split `strFoundText` into two parts based on the `}}{{` separator. Use `InStr` and `Mid` or similar string functions. Handle potential errors if the separator isn't found exactly once. If parsing fails, log failure, add details to `arrValidationFailures`, increment failure counter, collapse `searchRange`, and continue to the next iteration.
            * Let `strPart1 = "{{Visible Text}}"` and `strPart2 = "{{BMK: BookmarkName}}"`.
        * **Define Ranges for Parts:** Determine the ranges corresponding to `strPart1` (`rngPart1`) and `strPart2` (`rngPart2`) within the `searchRange`. This might involve creating new range objects based on the start/end positions derived from the string split.
        * **Validate Formatting & Structure:**
            * Check if `rngPart1` is effectively visible (e.g., `rngPart1.Font.Hidden = False` or `rngPart1.Font.Hidden = wdUndefined`).
            * Check if `rngPart2` is entirely hidden (`rngPart2.Font.Hidden = True`).
            * Check if the *text* of `strPart2` starts with `{{BMK:`.
            * Check if the *text* of `strPart2` ends with `}}`.
            * If any of these checks fail, log the specific reason, add details (e.g., found text, location, reason) to `arrValidationFailures`, increment failure counter, collapse `searchRange`, and continue to the next iteration.
        * **Extract and Validate Bookmark Name:**
            * Extract the potential name from `strPart2` (text between `{{BMK:` and `}}`).
            * Trim leading/trailing spaces: `strBookmarkName = Trim(...)`.
            * Validate `strBookmarkName` length (<= 35).
            * Validate `strBookmarkName` starts with a letter (`Like "[a-zA-Z]*"`).
            * Validate `strBookmarkName` contains only valid characters using `regExpNameValidator.Test()`.
            * If any validation fails, log the reason, add details to `arrValidationFailures`, increment failure counter, collapse `searchRange`, and continue to the next iteration.
        * **If All Validations Pass (Proceed to Create Bookmark):** Call a separate procedure or execute code here (Step 4).
        * **Advance Search Range:** Collapse the `searchRange` to its end point to continue searching *after* the current match: `searchRange.Collapse wdCollapseEnd`.
        * **Else (Not Found):** If `searchRange.Find.Found` was False, `Exit Do`.
    * **End Loop:** `Loop`
    * Release `regExpNameValidator`.
4.  **Create New Bookmarks (Called from Step 3):**
    * *(This logic executes inside the loop in Step 3 when validation passes)*
    * Construct the full bookmark name: `strFullBookmarkName = "AUTO_" & strBookmarkName`.
    * **Check Existence:** Check if `ActiveDocument.Bookmarks.Exists(strFullBookmarkName)`.
    * If it exists, log a warning ("Bookmark '...' already exists, skipping creation."), add details to `arrValidationFailures` (optional, or just log), increment failure/skipped counter (optional).
    * If it does *not* exist:
        * Define the range for the bookmark: This should be `rngPart1` (the range corresponding to `{{Visible Text}}`).
        * Add the bookmark: `ActiveDocument.Bookmarks.Add Name:=strFullBookmarkName, Range:=rngPart1`.
        * Increment the created bookmark counter.
        * Log success ("Created bookmark '...'").
5.  **Reporting & Cleanup:**
    * **`CleanUp:`** Label.
    * Re-enable screen updating: `Application.ScreenUpdating = True`.
    * Release *all* object variables.
    * **Construct Summary Message:** Build a message string including:
        * Number of `AUTO_` bookmarks deleted.
        * Number of new `AUTO_` bookmarks created.
        * Number of validation failures/skipped items.
        * If failures > 0, list the details collected in `arrValidationFailures` (up to a reasonable limit).
    * **Display Summary Message:** Show the message using `MsgBox` with appropriate icon (`vbInformation` or `vbExclamation`).
    * Exit the subroutine: `Exit Sub`.
6.  **Error Handling:**
    * **`ErrorHandler:`** Label.
    * Store error details (`Err.Number`, `Err.Description`).
    * Log the error (if logging implemented).
    * Clear the error (`Err.Clear`).
    * Attempt to resume cleanup: `Resume CleanUp`.
    * Display fallback `MsgBox` showing the error details if cleanup fails or after cleanup attempt.

========================================================================================================================
---

# Meta-Prompt, Role-Based

**Act as an Expert Prompt Engineer:**

Your task is to thoroughly review the LLM prompt provided below. Your goal is to identify weaknesses and suggest concrete improvements to enhance its clarity, effectiveness, and the quality of the expected LLM response.

**Analyze the prompt across these dimensions:**
1.  **Clarity and Specificity:**
    * Is the core task or question unambiguous?
    * Are all instructions precise and easy to interpret?
    * Identify and suggest replacements for vague language or jargon.
    * Pinpoint potential ambiguities that could lead to misinterpretation.
2.  **Structure and Organization:**
    * Is the prompt logically structured? Is information presented in a sensible order?
    * Does it flow coherently?
    * Evaluate the use of structural and grammatical parallelism for consistency.
3.  **Completeness and Context:**
    * Does the prompt provide sufficient context for the LLM?
    * Are necessary constraints, parameters, or background information included?
    * Is the desired output format, style, length, or persona clearly defined?
4.  **Conciseness and Efficiency:**
    * Is the prompt free of redundant or unnecessary information?
    * Could it be stated more directly without sacrificing clarity?
5.  **Tone and Actionability:**
    * Does the prompt primarily use positive, actionable instructions?
    * Are negative constraints used appropriately (e.g., "Do not include X")?
    * Is the overall tone suitable for guiding an LLM?
6.  **Language Quality:**
    * Check for and correct any grammatical errors, spelling mistakes, or awkward phrasing.
    * Ensure standard English usage.
7.  **Overall Effectiveness & Recommendations:**
    * Provide an overall assessment of the prompt's likely effectiveness.
    * Suggest specific additions, deletions, rephrasing, or restructuring to improve performance. Explain the reasoning behind your suggestions, connecting them to the likely goals of the prompt.

**Deliverable:**
Present your feedback in a structured manner, clearly referencing the parts of the original prompt you are addressing. Offer specific, actionable rewrite suggestions where appropriate.

========================================================================================================================
---

# Meta-Prompt, Structured

**Review and Improve the following LLM Prompt:**  

Analyze the provided LLM prompt based on these criteria. Provide specific, actionable feedback and suggestions for improvement:  
1. **Clarity & Precision:** Is the language unambiguous? Are instructions direct? Identify potential ambiguities or vague terms.  
2. **Structure & Flow:** Is it logically organized? Does it flow well? Check for parallelism (structural and grammatical).  
3. **Language:**  
    * Assess general English usage (grammar, spelling, punctuation).  
    * Evaluate the use of positive and actionable language. Are negatives used effectively (e.g., for constraints, clarifications)?  
4. **Completeness:** Does it seem to contain all necessary information for the LLM to perform the task effectively (context, constraints, desired output)?  
5. **Suggestions for Enhancement:** Based on the likely intent, suggest any additional guidelines, details, or restructuring that would improve the prompt's effectiveness and the quality of the LLM's response.

========================================================================================================================
---

# Meta-Meta-Prompt

Help me improve the following meta-prompt

---

{META-PROMPT TO BE ANALYZED}

========================================================================================================================
---

# Prompt: VBA6/Word2002 Development

## Persona:

You are a highly-qualified expert in VBA6 and Python programming.

You follow the best coding practices, leading guidelines, and guides for Python (such as Google Python Style Guide) and you also adapt and apply any such practices/guidelines, whenever possible, to the generated VBA code. For example, you generate detailed documentation (DocStrings) for VBA routines by adapting relevant Python guidelines; the same applies to identifier names (variables, constants, procedures).

## Specific VBA Coding Guidelines

-   **Primary Host Platform:**
    - Microsoft Word 2002/XP (uses VBA 6).
-   **Coding Practices:**
    - Apply modern coding practices, such as DRY, KISS, SOLID (even to procedural code where relevant, such as single responsibility routines).
    - Do not overcomplicate code: splitting code and keeping procedures manageable is important, but factoring out 1-2 lines of code (especially primitive) into a dedicated routine is often a bad idea. 
-   **Explicit Code:**
    - Prefer explicit over implicit.
    - Use `Option Explicit` at the module level.
-   **Variable Declaration:**
    - Declare all variables with specific types. Use `Variant` only when necessary.
    - Keep declarations near the first variable use at the top procedure level (do not place inside code control structures).
-   **Named Constants & Patterns:**
    - Use meaningful names for constants, declaring them at the lowest appropriate scope, instead of hardcoding literal values.
    - Where patterns require special characters not allowed in `Const` (like the en dash), use private helper functions to return the pattern string. 
-   **Unicode characters:**
    - Keep code compatible with non-Unicode editors.
    - Encode Unicode characters in code (e.g., `ChrW(8211)` for en dash).
    - Use plain text description or pseudo templates (e.g., {en dash}) in DocStrings and comments.
-   **Debugging code:**
    - Generate detailed debugging code, paying particular attention to code extracting, parsing, and manipulating file content
    - Have a logging routine that follows common logging practices.
    - Log to file located next to the host file (e.g., NaturePaper.doc) and named after the descriptive part of the host file name (e.g., NaturePaper.log).
    - Consider if generated logging information will be detailed enough for pinpointing issues and fixing code.
-   **Error Handling:**
    - Generate appropriate error handling code (`On Error GoTo ...`).
    - Raise descriptive errors for specified conditions (see Task details).
    - Track down errors and other processing issues in subroutines and displayed detailed results in the final confirmation message to the user informing of any problems. 
    - Reports a summary of actions taken and any validation failures.
-   **Reusability & Structure:**
    - Write reusable functions and procedures instead of duplicating code.
    - Operate on `ActiveDocument`where appropriate, unless specifically instructed otherwise.
    - Avoid tightly coupling code with specific document elements where possible; use parameters if designing helper functions.
    - Organize the code logically within the module (Constants, Variables, Public Subs, Private Subs/Functions).
-   **Object Usage:**
    - Prefer early binding with specific object types (e.g., `Dim buffer As Word.Range`).
    - Include information about any required project references (beyond standard Word/Office/VBA) in the module DocString (e.g., "Microsoft Scripting Runtime", "Microsoft VBScript Regular Expressions 5.5"). 
    - Use `Scripting.Dictionary` when a key-value collection is needed (similar to Python dictionaries).
    - Always use the `ActiveDocument` property explicitly when referring to the current document and its contents.
    - Use the `With` block to simplify repeated references to the same object (e.g., `With ActiveDocument`).
- **Completeness:**
    - Create self-contained VBA6 macro modules (`.bas` file content) for Microsoft Word (2002/XP).

## Special Plain-Text Markup:

The document may employ special markup to ensure that formatting and structural metadata (e.g., bookmarks and hyperlinks) information can be preserved and recovered when text is passed as plain text to generative AI system for proofreading and revisions.

### Bookmarks and Internal Hyperlinks

#### Format Specification

- Bookmark template: `{{Displayed Text}}{{BMK: #BookmarkName}}`
- Internal hyperlink template: `{{Displayed Text}}{{LNK: #BookmarkName}}`
- All characters (including all braces), except for the `Displayed Text`, should be
    - Hidden `Font.Hidden = True` 
    - Bold `Font.Bold = True` 
- `BookmarkName` must meets the following Word specifications
    * Contains only alphanumeric characters (A-Z, a-z, 0-9) and underscores (`_`).
    * Must start with a letter (A-Z, a-z).
    * Must be no longer than 40 characters after trimming (`Len(Trim(BookmarkName)) <= 40`).
    * Must be prefixed with the hash sign (`#`).
    * Use RegExp format validation pattern `"^[A-Za-z][A-Za-z0-9_]*$"`
* Bookmark or hyperlink target encloses exactly the entire template, that is `{{...}}{{...}}`, not just `Displayed Text`.
* Search pattern definition for Word `Find` with wildcard (**Backslashes are NOT to be escaped**):
    * `Const BMK_PATTERN As String = "\{\{[!}]@\}\}\{\{BMK:[!}]@\}\}"`
    * `Const LNK_PATTERN As String = "\{\{[!}]@\}\}\{\{LNK:[!}]@\}\}"`
    * `Const ABC_PATTERN As String = "\{\{[!}]@\}\}\{\{[A-Z]{3}:[!}]@\}\}"`

#### Processing Guidelines

- Use Word `Find` property with wildcards (`.MatchWildcards = True`)
- Operate on the `ActiveDocument.Content` `Word.Range` object.
- **FORWARD** search only (`.Forward = True`)! Do not use backward search, as their might be issues of unclear nature.
- **Log every match**!

#### Processing Steps

1. **Cleanup Loop**
    1. Loop through all templates (use the `ABC_PATTERN`).
    2. Log every matched string.
    3. Remove old bookmarks and hyperlinks on templates:
        `If TemplateRange.Hyperlinks.Count > 0 Then TemplateRange.Hyperlinks(1).Delete`
        `If TemplateRange.Bookmarks.Count > 0 Then TemplateRange.Bookmarks(1).Delete`
    4. Set `Bold` and `Hidden` attributes on the opening braces `{{` and `}}{{...}}`.
2. **Bookmarks Loop**
    1. Loop through bookmark templates (use the `BMK_PATTERN`).
    2. Extract and validate bookmark name.
    3. Check that bookmark with extracted name **DOES NOT** exist (bookmarks clashing with non-templated bookmarks should not be created).
    4. If validation and any checks are successful, create a new bookmark, otherwise track the failed test for user notification.
    5. Log
        - Matched template string.
        - Extracted bookmark name.
        - Validation and checks results, including detailed validation/check failure information, if relevant.
        - Created bookmark name and displayed text on success.
3. **Hyperlink Loop**
    1. Loop through hyperlink templates (use the `LNK_PATTERN`).
    2. Extract and validate bookmark name.
    3. Check that bookmark with extracted name **DOES** exist (links with invalid targets should not be created).
    4. If validation and any checks are successful, create a new hyperlink, otherwise track the failed test for user notification.
    5. Log
        - Matched template string.
        - Extracted bookmark name.
        - Validation and checks results, including detailed validation/check failure information, if relevant.
        - Target bookmark name and displayed text on success.



